from time import sleep
import signal
import sys
import threading

DEBUG = len(sys.argv) > 1

def cerrar(__, _):
    print("\nSaliendo")
    exit(1)

signal.signal(signal.SIGINT, cerrar)

def calculate_key(ct: bytes, know: bytes):
    return bytes(ct ^ k for ct, k in zip(ct, know))

def generar(length):
    max_num = 256 ** length
    return (f"{i:0{length * 2}x}" for i in range(max_num))

def crypt(ct, key):
    return bytes(f ^ k for f, k in zip(ct, key))

def romper_llave(ct, prefix, start, end):
    # Convertir el generador a una lista para poder acceder por índice
    hex_values = list(generar(5))
    for i in range(start, end):
        data = bytes.fromhex(hex_values[i])
        key = calculate_key(ct, prefix) + data
        key *= len(ct) // len(key) + 1
        key = key[:len(ct)]
        print(data)
        try:
            print("Texto descifrado: ", crypt(ct, key).decode())
        except UnicodeDecodeError:
            if DEBUG:
                print(crypt(ct, key))
                input("Pulse cualquier tecla para continuar...")
            pass

ct = bytes.fromhex("b3f0716f4a94ef6a6d6ce2b908d52d53c64696af67477dcade387770829324f23852fe78aff3266b5780")
print("Texto cifrado: ", ct.hex())
sleep(1)

print("Rompiendo llave...")

# Dividir el trabajo entre varios hilos
num_threads = 4  # Número de hilos
max_num = 256 ** 5  # Cambia esto según el tamaño de la llave
chunk_size = max_num // num_threads

threads = []
for i in range(num_threads):
    start = i * chunk_size
    end = (i + 1) * chunk_size if i < num_threads - 1 else max_num
    thread = threading.Thread(target=romper_llave, args=(ct, b"CodeVinciCTF{", start, end))
    threads.append(thread)
    thread.start()

# Esperar a que todos los hilos terminen
for thread in threads:
    thread.join()
