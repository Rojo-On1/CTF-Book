-- ğŸ¦œ Reverse list + apply Fibonacci obfuscation  
ğŸŒ€ :: [ğŸŒŒ] -> [ğŸŒŒ]  
ğŸŒ€ [] = []  
ğŸŒ€ ğŸ = ğŸŒŠ (ğŸŒªï¸ ğŸ) (ğŸŒ¿ ğŸ)  
  where  
    ğŸŒªï¸ ï¿½ = reverse ï¿½  
    ğŸŒ¿ ï¿½ = take (length ï¿½) (ğŸ¦” 1 1)  
    ğŸ¦” ğŸ¥¥ ğŸ¥ = ğŸ¥¥ : ğŸ¦” ğŸ¥ (ğŸ¥¥ + ğŸ¥)  
    ğŸŒŠ ï¿½ ğŸ = zipWith (\ğŸŠ ğŸ‹ -> ğŸŠ + ğŸ‹ `mod` 256) ï¿½ ğŸ  

-- ğŸ¦‰ Double XOR + Modular arithmetic  
ğŸ¦‰ :: [ğŸ”¢] -> [ğŸ”¢]  
ğŸ¦‰ ğŸ = [ (ğŸŠ ğŸ (ğŸ `mod` 3 + 5)) | ğŸ <- ğŸ ]  
  where ğŸŠ ğŸ¥ ğŸ¥¥ = xor (xor ğŸ¥ ğŸ¥¥) (ğŸ¥ * 2)  

-- ğŸ¦… Pad with prime numbers  
ğŸ¦… :: [ğŸ”¢] -> [ğŸ”¢]  
ğŸ¦… ï¿½ = take 16 (ğŸ ++ [ if isPrime ğŸŠ then ğŸŠ else 0 | ğŸŠ <- [2..] ])  
  where  
    isPrime ğŸ¥ = null [ ğŸ¥¥ | ğŸ¥¥ <- [2..ğŸ¥-1], ğŸ¥ `mod` ğŸ¥¥ == 0 ]  

-- ğŸ¦¢ Convert to ASCII + ROT13  
ğŸ¦¢ :: [ğŸ”¢] -> ğŸ·ï¸  
ğŸ¦¢ ğŸ‡ = [ chr ((ğŸ - 7) `mod` 128) | ğŸ <- ğŸ‡ ]  

-- ğŸ”’ Encrypted secret (dynamic XOR + emoji math)  
ğŸ”’ :: [ğŸ”¢]  
ğŸ”’ = [ (ğŸŠ ğŸ (index + 10)) | (ğŸ, index) <- zip [ğŸ¦œ, ğŸ¦‰, ğŸ¦…, ğŸ¦¢, ğŸ¦”, ğŸ¦š, ğŸ¦©] [0..] ]  
  where  
    ğŸŠ ğŸ¥ ğŸ¥¥ = xor ğŸ¥ (ğŸ¥¥ * 2 + 1)  
    ğŸ¦œ = 0x4B  
    ğŸ¦‰ = 0x6F  
    ğŸ¦… = 0x44  
    ğŸ¦¢ = 0x65  
    ğŸ¦” = 0x56  
    ğŸ¦š = 0x69  
    ğŸ¦© = 0x6E  

-- ğŸš© Final flag  
ğŸš© :: ğŸ·ï¸  
ğŸš© = "CodeVinciCTF{" ++ ğŸ¦¢ (ğŸ¦… (ğŸ¦‰ (ğŸŒ€ ğŸ”’))) ++ "}"  