import socket
import threading
import signal
import sys

def cerrar(stack, outher):
    print("\nSaliendo...")
    exit(1)

if len(sys.argv) < 2:
    print("Usage: <URL> <PORT>")
    exit(1)

signal.signal(signal.SIGINT, cerrar)
host = sys.argv[1]
port = int(sys.argv[2])

def filtar(rutas):
    return rutas.split("\n\n")[0].split(":")[1].split()

def obtener_rutas(host, port):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        try:
            s.connect((host, port))
            print(f"Conectado a {host}:{port}")
            s.recv(1024)  # Recibir datos innecesarios
            mensaje = "/\n"
            s.sendall(mensaje.encode('utf-8'))
            print(f"Mensaje enviado: {mensaje.strip()}")
            respuesta = s.recv(4096)
            rutas_disponibles = respuesta.decode('utf-8')
            print("Rutas disponibles recibidas del servidor:")
            rutas_filtradas = filtar(rutas_disponibles)
            return rutas_filtradas
        except ConnectionRefusedError:
            print("No se pudo conectar al servidor. Asegúrate de que esté en ejecución.")
        except Exception as e:
            print(f"Ocurrió un error: {e}")

def extraer_flags(respuesta):
    # Buscar la línea que contiene el flag
    lineas = respuesta.split("\n")
    for linea in lineas:
        if "CodeVinciCTF{" in linea and "I'm_not_the_real_flag_uwu" not in linea:
            return linea.strip()  # Retornar el flag encontrado
    return None  # Si no se encontró ningún flag

def es_hoja(respuesta):
    return "error" in respuesta.lower() and "flag" not in respuesta.lower()

def procesar_ruta(host, port, ruta, visitadas):
    if ruta in visitadas:
        return  # Evitar ciclos
    visitadas.add(ruta)

    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        try:
            s.connect((host, port))
            print(f"Conectado a {host}:{port} para la ruta: {ruta}")

            # Recibir datos basura al conectarse
            s.recv(1024)  # Recibir datos innecesarios

            mensaje = f"{ruta}\n"  # Asegurarse de que la ruta sea absoluta
            s.sendall(mensaje.encode('utf-8'))
            print(f"Ruta enviada: {mensaje.strip()}")
            respuesta = s.recv(4096).decode('utf-8')
            if "CodeVinciCTF{I'm_not_the_real_flag_uwu}" not in respuesta:
                print(respuesta)
                exit(1)

            # Extraer el flag de la respuesta
            flag = extraer_flags(respuesta)
            if flag:
                print(f"Flag encontrado: {flag}")
                # Guardar el flag en un archivo
                with open("flags.txt", "a") as f:
                    f.write(flag + "\n")
                return  # Si encontramos un flag válido, terminamos la búsqueda

            # Si es una hoja, no continuar
            if es_hoja(respuesta):
                print(f"La ruta {ruta} es una hoja.")
                return

            # Si no encontramos un flag y no es una hoja, buscar nuevas rutas
            nuevas_rutas = filtar(respuesta)
            for nueva_ruta in nuevas_rutas:
                ruta_absoluta = f"{ruta}/{nueva_ruta}"  # Construir ruta absoluta
                procesar_ruta(host, port, ruta_absoluta, visitadas)  # Llamada recursiva

        except ConnectionRefusedError:
            print("No se pudo conectar al servidor. Asegúrate de que esté en ejecución.")
        except Exception as e:
            print(f"Ocurrió un error: {e}")

def main():
    visitadas = set()  # Conjunto para rastrear rutas visitadas
    # Obtener rutas
    rutas = obtener_rutas(host, port)
    if rutas:
        print("Rutas filtradas:")
        for ruta in rutas:
            print(ruta)

        # Procesar cada ruta en un hilo
        for ruta in rutas:
            procesar_ruta(host, port, f"/{ruta}", visitadas)  # Iniciar con ruta absoluta
    else:
        print("No se encontraron rutas válidas.")

if __name__ == "__main__":
    main()

